# 17O: generate ewma
      df[, (ewma.fields) := as.double(NaN)]

      # first, calculate which exponent we want to put through (pass a different
      # on for each exp)
      # subset df to only valid rows
      tmp <- data.frame(
        "before" = abs(df$agedays - c(NA, df$agedays[1:(nrow(df)-1)])),
        "after" = abs(df$agedays - c(df$agedays[2:(nrow(df))], NA))
      )
      maxdiff_e <- sapply(1:nrow(tmp), function(x){max(tmp[x,], na.rm = TRUE)})
      exp_vals <- rep(-1.5, nrow(tmp))
      exp_vals[maxdiff_e > 365.25] <- -2.5
      exp_vals[maxdiff_e > 730.5] <- -3.5
      df[, exp_vals := exp_vals]

      # calculate ewma
      df[, (ewma.fields) := ewma(agedays, tbc.sd, exp_vals, TRUE)]

      # calculate dewma
      df[, `:=`(
        dewma.all = tbc.sd - ewma.all,
        dewma.before = tbc.sd - ewma.before,
        dewma.after = tbc.sd - ewma.after
      )]

      # add differences for convenience
      df[, diff_prev := (v-dplyr::lag(v))]
      df[, diff_next := (dplyr::lead(v)-v)]

      if (nrow(df) > 2){
        # 17P/R: identify pairs and calculate exclusions
        df[, pair := (v-dplyr::lag(v)) < mindiff_prev |
             (dplyr::lead(v)-v) < mindiff |
             (v-dplyr::lag(v)) > maxdiff_prev | (dplyr::lead(v)-v) > maxdiff
        ]
        df[is.na(pair), pair := FALSE]
        df[pair & abs(dewma.before) > dplyr::lag(abs(dewma.after)),
           bef.g.aftm1 := TRUE]
        df[pair & abs(dewma.after) > dplyr::lead(abs(dewma.before)),
           aft.g.aftm1 := TRUE]

        # Q
        df[, val_excl := exclude]
        df[diff_prev < mindiff_prev & bef.g.aftm1, val_excl := "Exclude-Min-diff"]
        df[diff_next < mindiff & aft.g.aftm1, val_excl := "Exclude-Min-diff"]
        df[diff_prev > maxdiff_prev & bef.g.aftm1, val_excl := "Exclude-Max-diff"]
        df[diff_next > maxdiff & aft.g.aftm1, val_excl := "Exclude-Max-diff"]



      }

      else

        { # only 2 values
        # 17Q/R -- exclusions for pairs
        df[, val_excl := exclude]
        df[diff_prev < mindiff_prev & abs(tbc.sd) > dplyr::lag(abs(tbc.sd)),
           val_excl := "Exclude-Min-diff"]
        df[diff_next < mindiff & abs(tbc.sd) > dplyr::lead(abs(tbc.sd)),
           val_excl := "Exclude-Min-diff"]
        df[diff_prev > maxdiff_prev & abs(tbc.sd) > dplyr::lag(abs(tbc.sd)),
           val_excl := "Exclude-Max-diff"]
        df[diff_next > maxdiff &  abs(tbc.sd) > dplyr::lead(abs(tbc.sd)),
           val_excl := "Exclude-Max-diff"]
      }

      if (unique(df$subjid) == "444336" & unique(df$param == "HEIGHTCM")) {
        fwrite(df, "../data/mindiff_debug_NNNNN_lead_4_orig.csv")}

      # figure out if any of the exclusions hit
      count_exclude <- sum(df$val_excl != "Include")
      if (count_exclude > 0){
        if (nrow(df) > 2){
          df[, absval := abs(dewma.all)]
        } else {
          df[, absval := abs(tbc.sd)]
        }

        # choose the highest abssum for exclusion
        idx <- df$index[which.max(df[df$val_excl != "Include",
                                     absval])]

        exclude_all[ind_all == idx] <- df[index == idx, val_excl]

        #set up to continue on
        if (count_exclude > 1){
          testing <- TRUE

          df <- df[index != idx, ]
        } else {
          testing <- FALSE
        }
      } else {
        testing <- FALSE
      }
    }

    return(exclude_all)
  })(copy(.SD)), by = .(subjid, param), .SDcols = colnames(data.df)]
